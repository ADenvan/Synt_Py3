import time
import math


print("L 48. ###########################################################")
print("L 48. ###########################################################")
print("L 48. ###########################################################")
print("L 48. ###########################################################")
# Установка сторонних модулей.
# NumPy - Работа с многомерными массивами.
# Matplotlib - Отображение графиков.

# pip list - Текущие установлинные пакеты.





print("L 48. ###########################################################")
# Импорт собственных модулей.
import sys
NAME = "myModule"

def floor(x):
    print("Функция из модуля floor myModule.")
    return x

pprint.pprint(sys.path)




print("L 47. ###########################################################")
# Импорт стандартных модулейю. Команды import и from.
import pprint
# import math as mt  # as -Изменения имени библиотеки.

# {'__name__': '__main__', '__doc__': None, '__package__': None,
print(locals())  #
pprint.pprint(locals())





print("L 46. ###########################################################")
# Декораторы с параметрами. Сохранение свойств декорируемых функций.
from functools import wraps

# Декараторы функций с параметрами.
def df_decorator(dx=0.01):
    def func_decorator(func):
        @wrapper(func)
        def wrapper(x, *args, **kwargs):
            res = (func(x + dx, *args, **kwargs) - func(x, *args, **kwargs)) / dx
            return res

        # wrapper.__name__ = func.__name__
        # wrapper.__doc__ = func.__doc__

        return wrapper
    return func_decorator


# Функция к которому мы пременяем этот декоратор.
# @df_decorator(dx=0.001)  # Вариант вызова Функ.
def sin_df(x):
    """ Функция для вычесления производной синуса. """
    return math.sin(x)

# Вариант вызова йункции декоратора.
sin_df = df_decorator(x=0.001)(sin_df)

df = sin_df(math.pi/3)
print(df)

#------
# Потери имени и декорируемой функции.
print(sin_df.__name__)  # wrapper -
print(sin_df.__doc__)


print("L 45. ###########################################################")

# ТЕГ---Декораторы функций.
def func_decorator(func):
    # Для определения произволных аргументов-функций.
    def wrapper(*args, **kwargs):
        print(" ---- 1- Вызов Чтото делаем.")
        res = func(*args, **kwargs)
        print(" ---- 2- Вызов Чтото делаем.")
        return res
    return wrapper

# Функция с произвольным числом параметров. Возвращает люые значения.
def some_func(title, tag):
    print("Вызов функции -->some_func {title} end {tag}")
    return f"Возврат с -----some_func"


some_func = func_decorator(some_func)
# Вызов. Дикарируемая функция.
res = some_func("Python -->", "two args")
print(res)



# -------------------------------------------------------------
# Дикоратор Функция с замером времени работы.
def time_test(func):
    def wrapper(*args, **kwargs):
        st = time.time()  # До ее вызова.
        res = func(*args, **kwargs)
        et = time.time()  # После ее вызова.
        dt = st - et  # Вычитание разницы.
        print(f"Время работы: {dt} sec ")
        return res
    return wrapper


# Пример -Алгоритм Евкллида как пример.
@time_test
def get_nod(a, b):
    while a != b:
        if a > b:
            a -= b
        else:
            b -= a
    return a

# Быстрый Алгоритм Евклида.
@time_test
def get_fast_nod(a, b):
    if a < b:
        a, b = b, a
    while b:
        a, b = b, a % b
    return a

get_nod = time_test(get_nod)
get_fast_nod = time_test(get_fast_nod)

res_nod = get_nod(2, 1000000)
res_fast = get_fast_nod(2, 1000000)

print(res_fast)
print(res_nod)


print("L 44. ###########################################################")
# Заамыкания. Пока жива переменная что ссылаеться на функцию. Функция жива.
# Создаеться независемое локальное окружение.


def say44_name(name):
    def say_goodbye():
        print("Dont say me goodbye, " + name + "!")
    return say_goodbye


f = say44_name("aDENAS")
f()


def counter(start=0):
    def step():
        nonlocal start
        start += 1
        return step
    return step

# Можем удалить ненужные символы.
def strip_string(strip_chars=""):
    def do_strip(string):
        #  возвращает преобразованую строку.
        return string.strip(strip_chars)
    return do_strip


strip1 = strip_string()
strip2 = strip_string(" !?,.")

print("L 43. ###########################################################")
# Область видемости переменных.
# global/ nonlocal
N43 = 100


def my43_func(lst):
    global N43  # Глобальная облость видемости.
    N43 = 20
    for i in lst:
        ni = i + N43
        print(ni)

    def my43_nonloc():
        nonlocal ni  # Только внутри функции.
        ni += 5
        print("nonlocal: >", ni)
    my43_nonloc()
    print(f"{ni} < После Функции Nonlocal")


print(N43)
my43_func([N43, 0, 1, 2])

print("L 42. ###########################################################")
# Ананимные функции (lambda)
# lambda - Может быть записана как Элемент любой конструкции
def S42(A42, B42): return A42 + B42


S42(1, 2)  # 3

A42 = [4, 5, lambda: print("Print >labda index >2"),
       7, 8, lambda: print("Вызов Прина")]
A42[5]()  # < Вызыв лямбда.

# lambda filter
list42 = [5, 3, 0, -6, 8, 10, 1]


def get_files42(a, filter=None):
    if filter is None:
        return a
    res = []
    for x in a:
        if filter(x):
            res.append(x)
    return res


R42 = get_files42(list42, lambda x: x % 2 == 0)  # [0, -6, 8, 10]

print("L 41. ###########################################################")
# Рекурсивные функции

def recursive(value):
    print(value)
    if value < 4:
        recursive(value + 1)
    print(value)

recursive(1)


def fact41(n):
    if n <= 0:
        return 1
    else:
        return n * fact41(n - 1)


fact41(6)

# -------------------------------------------------------------
# Обход каталогов и Фаилов. Ирархических данных.
F41 = {
    'C:': {
        'Python L 41': ['python.exe', 'python.ini'],
        'Program File': {
            'Java': ['README.txt', 'Welcom.html', 'java.exe'],
            'MATLSB': ['matelab.bat', 'matelab.exe', 'mcc.dat']
        },
        'Windows': {
            'System32': ['acladit.dll', 'acluilu.cll', 'zipflip.zip']
        }
    }
}

# depth=0 -Глубина обхода. Формальный параметр
def get_files41(path, depth=0):
    # Перебераем словарь по ключам.
    for f in path:
        # Выводим ключи с учетом глубины
        print(" "*depth, f)
        # Делаем проверку если f Это словарь
        if type(path[f]) == dict:
            get_files41(path[f], depth + 1)
        else:
            # Дубем выводить списк фаилов в определеном каталоге.
            print(" "*(depth+1), " ".join(path[f]))


get_files41(F41)
# -------------------------------------------------------------


print("L 40. ###########################################################")
# ТЕГ---Упаковка-* **
# Операторы * И ** для упакавки и распаковки коллекций.

# Упаковка.
X40, *Y40 = (1, 2, 3, 4)  # * X<[1]/ Y<[2,3,4]
X40, *Y40 = [1, "a", True, 4]  # 1 / ['a', True, 4]
*X40, Y40, Z40 = "Python"  # X40['P', 'y', 't', 'h']/ Y40<'o'/ Z40<n
# *X40 = 1, 2, 3 Будет ошибка. Упаковка в упаковоное.

# Распаковка / списка / кортеж.
a40 = [1, 2, 3]
(a40,)  # ([1, 2, 3])  # Список.
(*a40,)  # (1, 2, 3)  # Кортеж.

# Распаков-Любых итерируемых объектов.
D40 = -3, 3  # (-3, 3)
range(*D40)  # В диапазоне -3 3
list(range(*D40))  # [-3, -2, -1, 0, 1, 2,] Преоброзование в список.
[*range(*D40)]  # Автоматическая распаковка. [-3, -2, -1, 0, 1, 2,]
# [-3, -2, -1, 0, 1, 2, True, False, 1, 2, 3] # Обединения итерируемых объектов.
[*range(*D40), *(True, False), *a40]


S40 = {"все": 2, "ключи": 3, "перебор": 3, "в словарь": 4, "тут": 5}
# Множество из Ключей.
{*S40}  # {'тут', 'в словарь', 'все', 'перебор', 'ключи'}
# Множество из значений.
{*S40.values()}  # {2, 3, 4, 5}
# Кортежи Ключь Значчение
{*S40.items()}  # {('тут', 5), ('ключи', 3), ('все', 2), ('перебор', 3), ('в словарь', 4)}
# Можем обединить словари.
{**S40, **S40}

k40, kk40, *kkk40 = S40
# k40<'все'/ kk40<'ключи'/ kkk40<['перебор', 'в словарь', 'тут']

print("L 39. ###########################################################")
# ТЕГ---Упаковка-
# Функции с произвольным числом параметров *args и **kwargs
# * -Оператор упаковки агрумента. Произвольных аргументов. Тип(Картеж)
# *args -Произвольное число позиционых аргументов.
# **krwarg -Именованый аргумент. Тип{Словарь}.

def os_path39(disk, *args, sep='\\', **kwargs):
    args = (disk, ) + args
    if 'trim' in kwargs and kwargs['trim']:
        args = [x.strip() for x in args]
    path = sep.join(args)
    return path


P = os_path39("C:\\", "~stepic.org", " Тут сформируем строку pyton (питон)  ",
              " 39\\p39. Функция.docx ", sep='/', trim=True)
print(P)


print("L 38. ###########################################################")
# Фактические и формальные параметры.
# (a, b, c, -Фактические парметры.
# verbose=True) -Формальные параметры.
def get_V(a, b, c, verbose=True):
    if verbose:
        print(f"a = {a}, b = {b}, c = {c}")
    return a * b * c


v38 = get_V(b=1, a=2, c=3)  # Именованные аргументы.
v38 = get_V(1, 2, c=3)  # 1, 2, -Позиционные Аргу. c=3 -Именованые Аргу.

# Фактические и формальные параметры.
def cmp_str(s1, s2, reg=False, trim=True):
    if reg:  # Если Trye
        s1 = s1.lower()
        s2 = s2.lower()
    if trim:  # Если Trye
        s1 = s1.strip()
        s2 = s2.strip()
    return s1 == s2


print(cmp_str("Python ", " PYTHON", True))  # Будет труе
print(cmp_str("Python ", " Python", trim=False))  # Будет труе

# lst=None -Фармальный параметр. Всегда ссылаеться на пустой список.
def add_value(value, lst=None):
    if lst in None:  # Указываем не изменяемый тип Данных.
        lst = []
    lst.append(value)
    return lst

# L38 = add_value(1)
# L38 = add_value(2, L38)


print("L 35. ###########################################################")
# Алгоритм Евклида для нахождения НОД. Для нахождения наибольшего делителя.


def get_nod(a, b):
    while a != b:
        if a > b:
            a -= b
        else:
            b -= a
    return a


def test_nod(func):
    a = 2
    b = 100000000
    sT = time.time()
    res = func(a, b)
    eT = time.time()
    dT = eT - sT
    if res == 2 and dT < 1:
        print("# test 3 - ok")
    else:
        print("# test 3 - ng")


test_nod(get_nod)
A37 = get_nod(18, 24)
print(A37)


print("L 36. ###########################################################")

# return -Два значения с помощю кортежа
def get_sqrt(x):
    res = None if x < 0 else x ** 0.5
    return (res, x)
a, b = get_sqrt(49)

# Максимум из 3 аргументов с функ-из-2 параметров
def get_max2(a, b):
    return a if a > b else b
x, y, z = 5, 7, 10
print(get_max2(x, get_max2(y, z)))


def get_max3(a, b, c):
    return get_max2(a, get_max2(b, c))
print(get_max3(x, y, z))

# ---
PERIMETR = True
if PERIMETR:
    def get_rect(a, b):
        return 2 * (a + b)
else:
    def get_rect(a, b):
        return a * b
print(get_rect(19.5, 10.5))

# В Цикле функция если чет. не чет.
def even(x):
    return x % 2 == 0
for i in range(1, 20):
    if even(i):
        print(i)


print("L 35. ###########################################################")


def send_mail(from_name, old):
    text = f""" text {from_name}! end me {old} """


print("L 34. ###########################################################")
# ТЕГ---Генераторы множеств.
a34 = {x ** 2 for x in range(1, 5)}
a34 = {x: x ** 2 for x in range(1, 5)}  # Словарь.

# Тоже самое что и ЦИКЛ ГЕНЕРАТОР.
d34 = [1, 2, '1', '2', -4, 3, 4]
dd34 = {int(x) for x in d34}  # Через гинератор множеств. Сортируем от строк.
# equls_dd34 = set()  # Тоже самое что и ГЕНЕРАТОР.
# for x in d34:
#     equls_dd34.add(int(x))
# print(equls_dd34)
# С условием. Только положительные числа.
ad34 = {int(x) for x in d34 if int(x) > 0}

# Ключи заглавным : значения цифры.
M34 = {"все": 2, "ключи": 3, "будут": 3, "заглавными": '4', "тут": '5'}
A34 = {key.upper(): int(value) for key, value in M34.items}
print(type(M34))

# Меняем местами КЛЮЧИ и ЗНАЧЕНИЕ + УСЛОВИЕ.
AM34 = {int(value): key for key, value in M34.items() if 2 <= int(value) <= 5}


print("L 33. ###########################################################")
# Операции над множествами.
SeA33 = {1, 2, 3, 4}
SeB33 = {3, 4, 5, 6}

# intersection -Пересечение Двух.
SeA33 & SeB33  # Возвращает новое мнодество. Не изменя старый.
SeA33.intersection(SeB33)  # Возвращает результат пересечений.
SeA33.intersection_update(SeB33)  # Если хотим сохранить текущий результат.

# union -Обединение двух. Не изменя изначальный.
SeA33 | SeB33
SeA33.union(SeB33)

# Вычитание.
SeA33 - SeB33  # Вычетания один из другова.

# Несовпадающие Элементы.
SeB33 ^ SeB33  #

# Неравенство.
SeB33 < SeA33


print("L 32. ###########################################################")
# ТЕГ---Моножество/Методы
# set -Это неупорядоченная коллекция уникальных элементов.


A32 = {1, 2, 3, "Python"}  # Множество.
A32 = {1, 2, 3, "Python", 2, 3, "Python"}  # втоматически убирает дублирующие.
print(type(A32))
print(A32)
# set -Любой итерируемый объект.
set([1, 2, 3, 2, 1, -1])  # Нет дублий.
set("abrakadabra")
set(range(7))  #

B32 = set()
B32.add(3)  # Добавить 1 Эллемент.
B32.update([1, 2, 4, "StR", (1, 2)])  # Добавить множество.
B32.discard(2)  # Удаление Элемента без Error.
B32.pop()  # Удаляет и возврашает удаленный элемент.


print("L 31. ###########################################################")
# ТЕГ---Кортежи (tuple)
# Это упорядоченнаяб но НЕизменяемая коллекция данных.
# Значения изменять нельзя.

A31 = tuple()
A31 = (1,)
A31, B31, D31 = (11, 4, 5,)
A31, B31 = ["Python", "yo"]
A31 = B31[:]
A31

A31 = A31 + (1,)  # Обединение.
A31 += (("строка", "И", "Строка"),)

B31 = (0,) * 2

# tuple
T31 = tuple([1, 2, 3,])
T31 = tuple("Python")
T31 = (True, [1, 2, 3], "hello", 55, {"house": "дом"}, 55, 3)
# append -Именение списка.
T31[1].append("4")  # Именение списка.

# count -Поис элементов.
T31.count(55)  # 2 > 55 Поиск Элементов.

T31.index(3)  # Поиск первого наденого элемента.
T31.index(3, 2, 3)  # Поиск В пределах.

# in -Проверка вхождение значений.
[1, 2, 3] in T31  # True -такой элемент присутствует в кортеж T31


print("L 30. ###########################################################")
# ТЕГ---Словарь/Методы.

# dict.fromkeys(список + [,значения по умщлчанию])
lst30 = ["+7", "+6", "+5", "+4"]
A30 = dict.fromkeys(lst30)  # Можем создать словарь с задаными значениями.
A30 = dict.fromkeys(lst30, "Тут значение")
A30

# clear -Очистка.
A30.clear()  # Очистка.

# copy -
D30 = {True: 1, False: "ложь", 'list': [1, 2, 3], 5: 5}
DD30 = D30.copy()  # Копия. или так D2 = dict(D30)
DD30["list"] = [5, 6, 7]  # Изменения ЗНАЧЕНИЯ по ключю.

# get -Получить.
D30.get("list")  # Значение по ключю.
D30.get(3, False)  # Вернет если False нет.

# setdefault -Позволяет добавить если нет.
D30.setdefault(33)  # Добавить в словарь КЛЮЧЬ 33 и значение None
D30.setdefault(44, "+Значение")  # Ключь + значение.

# pop -Удаляет ключь. И ВОЗВРАТ.
D30.pop()  # Удаляет ключь из словаря И ВОЗВРАЩАЕТ содержимое словаря.
D30.pop(550, False)  # Елси ключа не существует. Вернет False

# popitem -Удаляет последню запесь.
D30.popitem()  # (5, 5)

# keys -Возвращает список ключей.
D30.keys()  # [True, False, 'list', 5]
# values -Список значений.
D30.values()  # [1, 'ложь', [1, 2, 3], 5]
# items -Обход ключя и значения.
for x in D30.items():
    print(x)  # (True, 1)(False, 'ложь')('list', [1, 2, 3])(5, 5)

for key, value in D30.items():  # Получение КЛЮЧ и ЗНАЧЕНИЕ.
    print(key, value)  # True 1 False ложь list [1, 2, 3] 5 5

# update -Обновления словаря.
upd30 = dict(one=1, tow=2, three="3", four="4")
upde30 = {2: "неуд", 3: "Удов", 'for': "Это значение перезаписсано", 5: "пять"}
upd30.update(upde30)

# ПОРЯДОК ОБЕДИНЕНИЯ ВАЖЕН.
updet30 = {**upde30, **upd30}  # ПОРЯДОК ОБЕДИНЕНИЯ ВАЖЕН.
upd30 | upde30  # Тоже самое.


print("L 29. ###########################################################")
# ТЕГ---Словарь dict(ключь=значение1, ключь=значение2,)
# <ключь> house : <значение> дом.
d29 = {"house": "дом", "car": "машина",
       "tree": "дерево", "road": "дорога", "river": "река"}

dd29 = {True: 1, False: "ложь", 'list': [1, 2, 3], 5: 5}
"list" in dd29  # Проверка наличия ключей в СЛОВАРЕ.
"ложь" not in dd29  # Этот ключь не входить в СЛОВАРЬ

len(dd29)  # 4
del dd29[True]  # Удаление КЛЮЧА.

# dict(ключь=значение1, ключь=значение2,)
dict(one=1, two=2, three='3', four='4')


print("L 28. ###########################################################")
# ТЕГ---Генераторы Вложиные списки (List comprehension)

# <Сповоб формирования значения>
#   for <Счетчик> in <Итеррируемый объект>
#   if <Условия>
a28 = [f"{i}*{j} = {i*j}"
       for i in range(3)
       for j in range(4)]  # ['0*0 = 0', '0*1 = 0',


matrix28 = [[0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23]]
# Используем ПЕРЕМЕННЫЙЕ что быле объявлены ранее.
b28 = [i
       for row in matrix28  # [0, 1, 2, 3, 10, 11, 12
       for i in row]


# Вложеный генератор списка.
M28, N28 = 2, 3
mat28 = [[i for i in range(M28)]
         for j in range(N28)]  # [[0, 1], [0, 1], [0, 1]]
print(mat28)
A28 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
AA28 = [[x ** 2 for x in row] for row in A28]  # Вложиные циклы. Многомерный.
# AAA28 = [x ** 2 for row in A28 for x in row]  Однострочный.

# Траснспонированые матрицы.
A28 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
T28 = [[row[i] for row in A28] for i in range(len(A28[0]))]
print(T28)

# Один вложен в другой. g(u(x+1)) = (x+1) ^ 2
G28 = [u ** 2 for u in [x + 1 for x in range(5)]]


print("L 27. ###########################################################")
# ТЕГ---Генераторы списков (List comprehension)
N27 = 6

# Генератор
# a27 = [0] * N27
# for i in range(N27):
#     a27[i] = i ** 2

# Генератор
# [<Список формирования> for <переменная> in <итерируемый объект>]
a27 = [i ** 2 for i in range(N27)]  # [0, 1, 4, 9, 16, 25]
# Остаток от деления.
b27 = [x % 4 for x in range(N27)]  # [0, 1, 2, 3, 0, 1]
b27
# Четные не четные.
# [True, False, False, False, True, False]
b27 = [x % 4 == 0 for x in range(N27)]
b27 = [0.5 * x + 1 for x in range(N27)]  # [1.0, 1.5, 2.0, 2.5, 3.0, 3.5]
print(b27)

# Список состаящий из чисел.
d_inp = "1 2 3 4"  # d_inp =  input("Целые числа через пробел: ")
aNum27 = [int(i) for i in d_inp.split()]  # [1, 2, 3, 4]


aStr27 = [i for i in "Python"]
t27 = ["Я", "б", "Python", "выуил", "если",
       "хватит", "сил", "терпения", "все", "запоимнить"]
# Длинна каждой строки.
bStr27 = [len(i) for i in t27]  # [1, 1, 6, 5, 4, 6, 3, 8, 3, 10]
# С условием. Составное
bStr27 = [i for i in range(-10, 5) if i < 0]  # [-10, -9,.... -1]
# С четное значение и те что кратно трем.
bStr27 = [i for i in range(-6, 7) if i % 2 == 0 and i % 3 == 0]  # [-6, 0, 6]
# Не больше 5. Длинна символов.
bStr27 = [i for i in t27 if len(i) < 5]  # 'Я', 'б', 'если', 'сил', 'все']
bStr27

# ternary
n27 = [4, 3, -5, 0, 2, 11, 122, -8, 9]
nTern27 = ["четное" if i % 2 == 0 else "НЕчетное"
           for i in n27
           if i > 0  # Тольько для положительных значений.
           ]  # ['четное', 'НЕчетное', 'четное', 'НЕчетное', 'четное', 'НЕчетное']
print(nTern27)


print("L 26. ###########################################################")
# Треугольник паскаля.
N26 = 7
P26 = []

for i in range(N26):
    row = [1] * (i + 1)
    for j in range(i + 1):
        if j != 0 and j != i:
            row[j] = P26[i-1][j-1] + P26[i-1][j]
    P26.append(row)
for i in P26:
    print(i)


print("L 25. ###########################################################")
# ТЕГ---Цыклы/Вложиные.

for i in range(1, 4):
    for j in range(1, 6):
        print(f"i = {i}, j = {j}", end=' ')
# print("\n")

# Сумирование.
a25 = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]
b25 = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]
c25 = []
for i, row in enumerate(a25):
    r = []
    for j, x in enumerate(row):
        r.append(x + b25[i][j])  # Сумма соответствующих элементов.
    c25.append(r)
# print(c25)

#
t25 = ["Задача вложинех циклов   Убираем",
       "линии пробелы    с помощю for end while   ."]
# line  -Ссылка на строку.
# i     -Индексом строки.
for i, line in enumerate(t25):
    while line.count('  '):   # Будит иска 2 пробела.
        line = line.replace('  ', ' ')
    t25[i] = line
# print(t25)

# Размерности двумерного списка.
# M, N = list(map(int, input("Введите М и Н: ").split()))
M, N = 2, 3
zeros25 = []
for i in range(M):
    zeros25.append([0] * N)
# print(zeros25)
for i in range(M):
    for j in range(N):
        zeros25[i][j] = 1
# print(zeros25)

# Строки заменить на столбцы. Траспонирование матрицы.
A25 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
for i in range(len(A25)):
    for j in range(i + 1, len(A25)):
        A25[i][j], A25[j][i] = A25[j][i], A25[i][j]
for i in A25:
    for j in i:
        print(j, end='\t')
    print()


print("L 24. ###########################################################")
# ТЕГ---Итератор.

d23 = [5, 3, 7, 10, 32]
it24 = iter(d23)
next(it24)  # Последовательной перебор.

s23 = "Python"
sIter = iter(s23)

r23 = range(5)
rIter = iter(r23)


print("L 23. ###########################################################")
# ТЕГ---Цикл for/enumerate

# Перебор.
for i in range(1, 7):
    print('*' * i)  # На каждую итерацию.

# Соединим строки и проставим пробел.
words23 = ["Python", "дай", "мне", "пройти", "этот", "курс"]
s23 = ''
for w in words23:
    s23 += ' ' + w
print(s23.lstrip())  # lstrip -Убераем пробел в начале.

# Заменить Двухзначнные числа 0.
digs23 = [4, 3, 100, -53, -30, 1, 34, -8]
for i in range(len(digs23)):
    if 10 <= abs(digs23[i]) <= 99:
        digs23[i] = 0  # Оброщение к элементу по индексу для изменения.
print(digs23)

# индекс, значение = enumerate(объект)
digs23 = [4, 3, 100, -53, -30, 1, 34, -8]
for i, d in enumerate(digs23):
    if 10 <= abs(d) <= 99:
        digs23[i] = 0
print(digs23)


# Вычесление факториала с клавиатуры.
# n23 = int(input("Введите натуральное число не больше 100"))
n23 = int(5)
if n23 < 1 or n23 > 100:
    print("Неверно введено натуральное число")
else:
    p23 = 1
    for i in range(1, n23 + 1):
        p23 *= i
        print(f"Факториал {n23}! = {p23}")

# Латиница
t23 = ['a', 'b', 'v', 'g', 'd', 'e', 'zh', 'z', 'i', 'y', 'k', 'l', 'm', 'n', 'o', 'p',
       'r', 's', 't', 'u', 'f', 'h', 'c', 'ch', 'sh', 'shch', '', 'y', '', 'e', 'yu', 'ya']
start_index = ord('а')
title = "Програмирование на Python - лучшей курс"
slug23 = ''

for i in title.lower():
    if 'а' <= i <= 'я':
        slug23 += t23[ord(i) - start_index]
    elif i == 'ё':
        slug23 += 'yo'
    elif i in " !?;:.,":
        slug23 += '-'
    else:
        slug23 += i

while slug23.count('--'):
    slug23.replace('--', '-')


print("L 22. ###########################################################")
# ТЕГ---ЦИКЛ for/range
d22 = [1, 2, 3, 4, 5]
# <оператор> for <счетчик> in <итерируемый объект>.
for x in d22:
    print(x)

# range -Генерирует арихметическую последовательность.
range(5)
list(range(5))
list(range(-10, -20, -2))  # Последовательность в обратном порядке.
list(range(5, -1, -1))  # От 5 до 0.

for i in range(len(d22)):
    d22[i] = 0

s22 = 0
for i in range(2, 1001):
    s22 += 1/i


print("L 21. ###########################################################")
# break
d21 = [1, 5, 3, 6, 0, -4]
flFind = False
i21 = 0
# Если число евляеться четным.
while i21 < len(d21):  # На всю длинну.
    # while i21 < len(d21) and d[i] % 2 != 0:
    flFind = d21[i21] % 2 == 0  # == Оператор вернет труе.
    if flFind:  # True если flFind.
        break
    i21 += 1
# print(flFind)

# continue
# sCont = 0
# dCont = 1
# while dCont != 0:
#     dCont = int(input("Введите цудое число: "))
#     if dCont % 2 == 0:
#         continue
#     sCont += dCont
#     print("sCont = " + str(sCont))

sEls = 0
iEls = -10
while iEls < 100:  # 100 При 100 else: не сработает.
    if iEls == 0:
        break
    sEls += 1/iEls
    iEls += 1
else:
    print("Суммф вычеслена корректна: ")

print(sEls)


print("L 20. ###########################################################")
# ТЕГ---while
n20 = 1000
i20 = 1
s20 = 0
while i20 <= n20 and i20 <= 50:
    s20 += i20
    i20 += 1
print(s20)

# Пока не станет True.
pass_true = "pass"
ps20 = ""
# while ps20 != pass_true:
# ps20 = input("")
# print("ps20 = input("")")

# Вывести число Кратно 3.
n20 = 20
i20 = 1
while i20 <= n20:
    if i20 % 3 == 0:
        print(i20)
    i20 += 1


print("L 19. ###########################################################")
# ТЕГ---Тернар/ ternary
a19 = -12
b19 = -77
res19 = abs(a19) if a19 > b19 else abs(b19)  # 12

# upper -Функциях.
s19, t19 = "puthon", 'upper'
res19U = s19.upper() if t19 == 'upper' else s19  # PUTHON

# На 3 индексе. В списках.
[1, 2, a19 if a19 > b19 else b19, 4, 5]  # [1, 2, -12, 4, 5]
# string -В строках.
"a >" + ("Чет.." if a19 % 2 == 0 else "НЕ ч.") + " число"  # 'a >Чет.. число'
# max -В функциях.
max(1, 5, a19 if a19 > 0 else b19, 4, 5)  # 5

# -
total19 = (19 if a19 > res19 else res19) if a19 > b19 else (
    b19 if b19 > res19 else res19)  # 12

# Цикл + Условие. Тольько для положительных значений.
n27 = [4, 3, -5, 0, 2, 11, 122, -8, 9]
nTern27 = ["четное" if i % 2 == 0 else "НЕчетное"
           for i in n27
           if i > 0  # Тольько для положительных значений.
           ]  # ['четное', 'НЕчетное', 'четное', 'НЕчетное', 'четное', 'НЕчетное']

# map + lambda -
sum(map(lambda x: x if x > 0 else 0, n27))  # 151


print("L 18. ###########################################################")
# ТЕГ---if
x = int(5)
if x % 2 == 0:
    if 0 <= x <= 9:
        print("x...Цифра")
    else:
        print("x - Число")
else:
    print("x --- Не четное число")

# if Max Min.
a18 = 10
b18 = 55
c18 = 7
if a18 > b18:
    if a18 > c18:
        print("a -> max")
    else:
        print("c -> max")
else:
    if b18 > c18:
        print("b -> max")
    else:
        print("c -> max")

# else if
item18 = int(1)
if item18 == 1:
    print("Print > ")
elif item18 == 2:
    print("C++ >")
elif item18 == 3:
    print("Java >")
elif item18 == 4:
    print("JavaScript > ")
else:
    print("new Leng ?")

if item18 < 0:
    print("itme - Положительным быть")
elif 0 <= item18 <= 9:
    print("item - цифра")
elif 10 <= item18 <= 99:
    print("item - Двухзначное число.")
elif 100 <= item18 <= 999:
    print("itme - Трехзначное число.")


print("L 17. ###########################################################")
# if
x = -4
if x >= -4 and x <= 10:
    x  # Вдиапозоне.

masks17 = [1, 5, 2, 6, 4]
if 2 in masks17:
    print("Print: if")
else:
    print("Print: else")


print("L 16. ###########################################################")
# Многомерный списки.

line = [1, 7, 6, 11, 3]
img = [[1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [
    1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3]]
# Структура многоменрных данных. Вложинех списков.
img = [line[:], line[:], line[:], line[:], line[:]]
img[0][1]  # Обрщение к элементу. Многомерному списку.
img[1] = [0, 0, 0, 0, 0]  # сформировали новый список и присвоили 2 элементом.
img[1] = [0] * 5  # Более короткий вариан изменения.
img[1][:] = [1] * 5  # Один из вариантов изменения.

del img[1]  # Удаление.

# Двумерный в одномерном списке.
A16 = [[[True, False], [1, 2, 3, 4]], ["Двумерный", "и", "Одномерный"]]
A16[0]
A16[1]
A16[0][1][0]  # [[[], [1]], []]


print("L 15. ###########################################################")
# Тег---Списки-Методы.

# append -Добавляяет и изменяет список.
a15 = [1, -14, 3, 23, 24, -45, 0]
a15.append(100)  # Добавляяет и изменяет список.
a15.append(True)
a15.append([1, 2, 3])

# insert -Встовляеть в список В Определеную (позицию-Индекс) Определенное Значение.
a15.insert(3, -1000)

# remove -Удаление из спичка По значению.
a15.remove(True)  # В bool предстовление 1 Это True/ 0 False/
a15.remove(-1000)

# pop -Удаляет по ИНДЕКСУ Элемент иNTз списка И ВОЗВРАЩАЕТ его.
a15.pop()  # Без аргумента удалит/Вернет последний Элемент.
rememberPop = a15.pop()  # Удалить и Запомнить Элемент.
rememberPop = a15.pop(3)  # По индексу. Удалить и Запомнить Элемент.

# clear -Очистка. Удаление всех элеменов.
a15.clear()

# copy -
c15 = a15.copy()  # Переменная будет сcылаться на другой объект.
c15 = a15[:]  # Cо срезам.
c15 = list(a15)  # Или.

# count -Позваляет найти число Элементов с указаным Значением.
c15.count(1)  # c15 Значение только 1.

# index -Возвращает ИНДЕКС первого наденого значения.
c15.index(3)
c15.index(3, 2)  # 2 Это сатартовое значение поиска.

# reverse -Обратной порядок.
c15.reverse()

# sort -Сортировка по убыванию. Меняе И НИЧЕГО не возвращает.
c15.sort()
c15.sort(reverse=True)
c15ListSortStr = ["Moscva", "Sanct-petesburg", "Tveri", "Kazani "]
c15ListSortStr.sort()  # Сортировка по лексике графическому.


print("L 14. ###########################################################")
# ТЕГ---Список/срезы
# [старт : стоп : шаг]

lst14 = ["Делаем 0", "срез 1", "Списка 2", "Удаляем 3 ", "Элемент 4"]
lst14[1:3]

# Новый скопированый список.
A14 = lst14[1:3]  # Копируем.
A14[0] = "VoroneJ"  # Исменяем под индексом 0.
A14  # Элементы индекса 0 1. Новый список. + Изменения.

b14 = lst14[:3]  # От 0 - 3.
c14 = lst14[2:]  # От 2 и до конца.

# Копия списка.
newCopyLst = lst14[:]  # Копия списка.
newCopyLst2 = list(lst14)

# Не создает копию списка.
NOcopyLst = lst14  # Не создает копию списка.

negaty = [1, 2, 3, 4, 5, 6]
negaty[2:-1]  # 3, 4, 5
negaty[-3:-1]  # 4, 5
# Добавляем шаг
negaty[1:5:2]  # 2, 4
negaty[:5:2]  # 1, 2, 5
negaty[::-1]  # 6, 5, 4, 3, 2, 1

# Изменения групы Элементов.
negaty[2:4] = ["Изменение", "Элементы"]
negaty[:5:2] = [0, 0, 0]  # Правельно присваеваем значения групе оэлементов.
negaty[2:4] = 10, 20

# Равенство списково.
eqalsList = [1, 2, 3] == [1, 2, 3]  # True
eqalsList = [1, 2, 3] != [1, 2, 3]  # False
eqalsList = [1, 2, 3] > [1, 2, 3]  # False
eqalsList = [10, 2, 3] > [1, 2, 3]  # True
eqalsList = [10, 2, 3] >= [1, 2, 3]  # True
eqalsList = [10, 2, 3, 10] > [1, 2, 3]  # True

eqalsList = [10, 2, 3] == [1, 2, "Error"]  # ERROR


print("L 13. ###########################################################")
# ТЕГ---Список/Методы.
# Список Это упоряДочиная коллекция.
# Списки Изменяемый Тип ДанныХ.


["Moscva", "tveri", "Vologda"]
marks13 = [1, 2, 4, 7, 10, 3]
(marks13[0] + marks13[1] + marks13[2] +
 marks13[3] + marks13[4] + marks13[5]) / 6

# Списки Изменяемый Тип ДанныХ.
marks13[0] = 8  # первое число Изменили на 8
marks13[1] = "Заменим на строку по ИНДЕКСУ"

# Вложиный списаок.
lst13 = ["Moskva", 12340, 5.00, True, "Tvari", False]  # Может быть любой.
lst1313 = [1, 2.3, [-1, 2, 44], 5, 7]  # Вложиный списаок.

# list() -Создает список. +Можем создавить копие списка.
b13 = list([True, False, 11])
b13_Listlist = list("Pytho")  # На основе ОБЪЕКТА создает список.

# len -
len([])  # Пустой.
len(marks13)  # Определение числа элементов в списке (длинна списка)

# min/max -
min(marks13)
min(b13_Listlist)  # Работает со строками
max(marks13)
max(b13_Listlist)

# sum -
sum(marks13)  # Вычесление суммы всех Чисел.
sum(marks13) / len(marks13)  # Среднея сумма чисел.

sort_marks13 = sorted(marks13)  # Осортированый список.  Создает новый список.
sort_marks13 = sorted(marks13, reverse=True)  # Обратная сортировка.

# + -Соединение двух списков в один.
[1, 2, 3,] + [4, 5]

# * -Дублирование списка.
["I", "love", "Python"] * 3
["Дублируем", "списки"] * 3 + ["ТРИ", "Радза"]

# in -Проверка вхождения элемента в список.
lstInList = ["Moscva", 1320, True, 5.6, "Tvari", False]
1320 in lstInList  # True
[1, 2] in lstInList  # False.

# del -Удаление Элемента списка.
del lstInList[2]  # Удален.


print("L 12. ###########################################################")
# ТЕГ---Строка/Вывод/
name12 = "Lesson 12"
namber12 = "12"

"Метод формат в " + name12 + " возвращает строку " + namber12 + " по шаблону"
"Метод формат в {less} возвращает строку {lessnamber} по шаблону".format(
    less=name12, lessNamber=namber12)

f"Ф строка Урока-{name12}-и номер урока-{namber12}-в Pyton 6v"
f"Ф строка Урока-{name12.upper()}-и номер урока-{namber12 + 5}-в Pyton 6v"
f"Ф строка Урока-{len(name12)}-и номер урока-{namber12 * 2}-в Pyton 6v"


print("L 11. ###########################################################")
tText = "\t<=Табуляция слеш N=>\nPython"
tText = "\\t<=Табуляция слеш N=>\\nPython"  # Экранирование.
tText = r"\\t<=Табуляция слеш N=>\\nPython"  # Сырые строки.
print(tText)


print("L 10. ###########################################################")
# ТЕГ---Строки/Методы


sUp = "Pyhon"
msg = "abrakadabra"  # Всего 10 от 0 - 10.

# upper/lower -Верхний и нижний регистр.
ret = sUp.upper()
ret = sUp.lower()

# count -сколько символов в строке.
msg.count('ra')  # 2
msg.count('ra', 4)  # Поис после 4 индекса в строке и до конца.
msg.count('ra', 4, 10)  # В диапазоне от 4 - 9 Индекса.

# find -Возвращает 1 наденый индес в под строке
msg.find("br")  # Находиться на 1 индехсе.
msg.find("br", 2)  # Поиск со 2 индоекса. Порог вхождения br c 8 индекса.

# rfind -
msg.rfind("br")  # 8 -Поиск с конца.

# index -
msg.index("br")  # Работает как find -Но может привести к ошибке.

# replace -
msg.replace("a", 'o')  # заменить все а на о.
msg.replace("ab", 'AB')  # заменить все ab на AB.
msg.replace("ab", '')  # На пустые строки.
msg.replace("a", 'O', 2)  # Максимальное чесло замен. Первые 2 а на О.

# isalpha - True Возврашает если строка состаит целеком из букв.
"worldHi".isalpha()  # True
"world Hi".isalpha()  # False Пробел не являеться бквой.

# isdigit() - True Если строка целеком состаит из Цифар.
"5005".isdigit()  # True
"50.05".isdigit()  # False.

# rjust/ljust -Возвращает НОВУЮ строку с заданном числом/width/ заданном.
rjd = "asd"
rjd.rjust(5)  # Строка состаит из 5 символов.
msg.rjust(13)  # Будет Состаять из 13.
nRj = "12"
nRj.rjust(4, '0')  # Добавит пару 00 в начале.

nRj.ljust(10, '*')  # Заполнем на 10 * с конца.

# split -Разбивает страку на СПИСКИ.
"Ivanov IvaN IvaNivaNNovich".split(" ")
digs = "1,  2,3,  4, 5,6"
digs.replace(" ", "").split(",")  # Удалить лишний пробел.
# ['1', '2', '3', '4', '5', '6']

# join -Из списка строк собирает строку.
d10 = digs.replace(" ", "").split(",")
", ".join(d10)  # Возвращает строку с добавленными символами.
# '1, 2, 3, 4, 5, 6'

fio = "В каждый пробел вставит зяпятую"
", ".join(fio.split())

# strip -Удаляет все символы пробела и переноса строк вначале и в конце строки.
"     Удаляет вначале и конце из строки       \n".strip()
"     Удаляет в конце из строки       \n".rstrip()
"     Удаляет в начале строки       \n".lstrip()


print("L 9. ###########################################################")
# ТЕГ---Список/Строка
s9 = "hello python"

s9[1]  # Обращение по индексу.
s9[-1]  # Обращение по индексу с конца.
"panda"[3]  # Обращение по индексу.


len(s9) - 1   # Обращение по индексу с конца.
s9[len(s9) - 1]  # По индексу с конца.

# Срез строки. [старт:стоп:шаг]
s9[1:3]  # Доходем до 3. А 3 не включаеться.
s9[:3]  #
s9[2:10:2]  # [старт:стоп:шаг]
s9[::2]  # Все символы через один
s9[::-1]  # Все Символы с конца и записаный на оборот.
s9[::-2]  # Символы с конца через один в строке s9.

# Строка не изменяемый тип. Для изменения создаем новую строку.
s9h = 'H' + s9[1:]
s9h


print("L 8. ###########################################################")
# ТЕГ---Строка/
text = '''Текст тут  - - - - - - - '''
s1 = "Строка № 1: "
s2 = "Язык Python s 2"

# конкатынацыия строк.
s1 + " " + s2
s1 + str(505)  # Позволяет преоброзовывать Аргумент в строку.

# Дублирования фрагмента строки.
"XA " * 5

# len - Выдает количество символов в строке.
len("Hello")
len(s1)

# in - Присутствует ли символы в строке из под строке.
'abr' in "abrkdbra"  # True

# Равенство строк.
s1 != "Равно или нет "  # True / Не равно s1.
"КОТ" > "КИТ"  # True

# ord -Опредиление кода символа.
ord('a')


print("L 7. ###########################################################")
# ТЕГ---Числа
# Проверка Х7 четное или нет
x7 = 6
x7 % 2 == 0  # True Проверка Х7 четное или нет

y7 = 7
y7 % 2 == 0  # False

# and / or # Числа в Диапазоне.
a7 = 1.85
a7 >= -2 and a7 <= 5  # True -2 <= a7 <= 5
a7 < -2 or y7 > 5  # False -2 >= a7 >= 5

# Кратность числа в диапазоне.
x7 % 2 == 0 or x7 % 3 == 0  # True
x7 % 2 != 0 or x7 % 3 != 0  # False

y7 % 2 != 0 and y7 % 3 != 0  # True
y7 % 2 == 0 and y7 % 3 == 0  # False

# not - самый высокий приоритет.
not (x7 % 2 == 0 or x7 % 3 == 0)  # False

# bool True False
bool(0)  # False
bool(10)  # True


print("L 6. ###########################################################")
# ТЕГ---Вывод/
# sep - разделитель между данными.
# end - завершающий символ или строка.
a6 = -6.87
b6 = 7
c6 = 25.9
print(a6, b6, c6, sep=" | ")  # + |
print("Hello", end=" <> ")  # + World!
print("World!")

print("Координаты точки: b6 = ", b6, "; c6 = ", c6, sep="")
(f"f Строка Коор точ: b6 = {b6}; c6 = {c6}")

# input() -Вод с консоля.
aPrint = input()
aPrint = int(aPrint)      # Преобразовываем в строку Цаелых чисел.
bPrint = abs(aPrint)
print(aPrint, type(aPrint))

fPrint = float(input())   # Преобразование дробных чисел.
print(fPrint)

# Вычесление Треугольника.
engl1 = float(input("Введите длину прямогугольника: "))
engl2 = float(input("Введите ширину прямогугольника: "))
print("Периметра Треугольника => ", 2 * (engl1 + engl2))

engle1, engle2 = map(float, input("Введите две стороны прямоугольника: ").split())


print("L 5. ###########################################################")
# ТЕГ---Математические/функции.
# Для вычесления модуля числа. Преобразования отрицательных чисел в положительные.
a = abs(1.5)

b = min(1, 2, 5, -10)
c = max(11, 55, 60)

# pow -Возведение в степень.
pow(6, 2)

# round -Округления либо меньше либо больше.
round(1.5)
round(7.8756, 2)    # Округлене до сотых.
round(7.849322, -1)  # Округление до тысечных.

max(1, 2, abs(-3), -10)
max(1, 2, abs(min(10, 5, -3)), 15)


print("Lessson 3. ###########################################################")
# p-1intВсе ("Символы с и записаный на оборот конца.
# p-1intВсе (2Симвос и через один.

# 3.s[ 3.s[
# Возведение в степень. Работает с права на лево.
d4 = 2 ** 3     # = 8
print(d4)
d4 = 36 ** 0.5  # = 6.0
d4 = 2 ** 3 ** 2  # = 512
d4 = 27 ** (1/3)  # = 3.0


# Остаток от диления.
d4 = 10 % 3     # = 1
d4 = -9 % 5     # = 1
d4 = 9 % -5     # = -1
d4 = -9 % -5    # = -4

# Округление к наименьшему целому.
d3 = 7 // 2  # 3 -
d3 = -7 // 2  # -4 -

# Каскадное переменная. id
a = b = c = 10
# print(id(a), id(b), id(c))

# Множественное присваиване
a, b = 12, 55
# print(a, b)

# type -Узнать Тип данных
x = 6.7
s = "Hello"
# print(type(x), type(s))


# ТЕГ---Методы сортировки.
matematycs_Sort_3 = [2, 4, 3, 5, 1]


def insert_sort(A):
    N = len(A)
    for top in range(1, N):  # От 1 индекса.
        k = top  # Временая.
        while k > 0 and A[k-1] > A[k]:
            A[k], A[k-1] = A[k-1], A[k]  # Меняем местами.
            k -= 1


def choise_sort(A):
    N = len(A)
    for pos in range(0, N-1):
        for k in range(pos + 1, N):
            if A[k] < A[pos]:
                A[k], A[pos] = A[pos], A[k]


def bubble_sort(A):
    N = len(A)
    for bypass in range(1, N):
        for k in range(0, N-bypass):
            if A[k] > A[k + 1]:
                A[k], A[k + 1] = A[k + 1], A[k]

# Рекурсия.


def matryshka(N):
    if N == 1:
        print("Матрёшка.")
    else:
        print("Верх Матрёшки N= ", N)
        matryshka(N-1)
        print("Низ матрешки N= ", N)


print(matryshka(5))
